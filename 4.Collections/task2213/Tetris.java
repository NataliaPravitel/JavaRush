package com.javarush.task.task22.task2213;

import java.awt.event.KeyEvent;
//Давай напишем игру Тетрис!
//
//Наш Тетрис будет состоять из двух вещей: поля из клеток и фигурки, которая падает.
//Поэтому для начала создай три класса: Field(поле с клетками), Figure(фигура) и сам Tetris.
//
//Также нам понадобится метод main в классе Tetris.
//
//
//Requirements:
//1. Класс Field должен быть создан в отдельном файле.
//2. Класс Figure должен быть создан в отдельном файле.
//3. Класс Tetris должен быть создан в отдельном файле.
//4. Класс Tetris должен содержать метод main.

//Тетрис(2)
//Отлично!
//Теперь добавь в класс Tetris два поля: field типа Field и figure типа Figure.
//
//
//Requirements:
//1. Поле field типа Field должно быть создано в классе Tetris.
//2. Поле figure типа Figure должно быть создано в классе Tetris.
//3. Поле field должно быть объявлено с модификатором доступа private.
//4. Поле figure должно быть объявлено с модификатором доступа private.

//Тетрис(3)
//Поле есть, фигура есть, а как их получить?
//
//Добавь геттеры для полей field и figure.
//
//
//Requirements:
//1. В классе Tetris должен быть создан метод getField без параметров.
//2. В классе Tetris должен быть создан метод getFigure без параметров.
//3. Метод getField должен быть объявлен с самым широким типом доступа.
//4. Метод getFigure должен быть объявлен с самым широким типом доступа.
//5. Метод getField должен возвращать значение поля field.
//6. Метод getFigure должен возвращать значение поля figure.

//Тетрис(4)
//Так же еще нам понадобится пара методов.
//Добавь в класс Tetris методы run() и step():
//
//run() будет отвечать за всю игру.
//А step() - за один шаг в игре.
//
//Тип возвращаемого значения void для обоих методов.
//Тут и в будущем, если нет явных указаний с каким модификатором доступа создавать метод,
// то он должен быть публичным, а поле приватным.
//*В общем случае, стоит руководствоваться правилом использования наиболее строгого(из возможных)
// модификатора доступа.
//*Т.е. если логика системы предполагает обращения к методу извне класса, мы не сможем сделать
// такой метод приватным.
//*Но также нет никаких причин указывать уровень доступа public для методов которые
// будут использованы только в рамках пакета.
//*Поначалу это кажется несущественным, но на самом деле это один из основополагающих принципов ООП.
//*Учись сразу делать правильно!
//
//
//Requirements:
//1. В классе Tetris должен быть создан метод run без параметров.
//2. В классе Tetris должен быть создан метод step без параметров.
//3. Метод run НЕ должен быть приватным.
//4. Метод step НЕ должен быть приватным.
//5. Метод run не должен возвращать значение.
//6. Метод step не должен возвращать значение.

//Тетрис(5)
//Теперь нужно создать объект самого Тетриса.
//Добавь в класс Tetris статическое поле game типа Tetris.
//Поле game НЕ должно быть приватным.
//
//Затем в методе main создай объект типа Тетрис и сохрани его в эту переменную.
//Затем добавь вызов метода run.
//
//
//Requirements:
//1. В классе Tetris должно быть создано поле game.
//2. Поле game НЕ должно быть приватным.
//3. Поле game должно быть статическим.
//4. Поле game должно быть типа Tetris.
//5. В методе main поле game должно быть инициализировано новым объектом типа Tetris.
//6. В методе main должен быть вызван метод run на объекте сохраненном в поле game.

//Тетрис(9)
//Если ты обратил внимание, мы пишем программу "сверху вниз".
//Сначала решили, какие классы нам нужны. Затем - какие методы.
//А потом уже начнем писать код этих методов.
//Таким образом мы разбиваем большую задачу на множество маленьких.
//Когда код всех методов будет готов, останется только проверить - так ли все работает, как должно быть.
//И если надо - внести некоторые изменения.
//
//
//Requirements:
//1. Пересмотри созданную структуру классов и обрати внимание на порядок написания программы.

/**
 * Класс Tetris - содержит основной функционал игры.
 */
public class Tetris {
    private Field field;                //Поле с клетками
    private Figure figure;              //Фигурка

    private boolean isGameOver;         //Игра Окончена?

    public Tetris(int width, int height) {
        field = new Field(width, height);
        figure = null;
    }

    /**
     * Геттер переменной field.
     */
    public Field getField() {
        return field;
    }

    /**
     * Геттер переменной figure.
     */
    public Figure getFigure() {
        return figure;
    }

    /**
     * Основной цикл программы.
     * Тут происходят все важные действия
     */
    public void run() throws Exception {
        //Создаем объект "наблюдатель за клавиатурой" и стартуем его.
        KeyboardObserver keyboardObserver = new KeyboardObserver();
        keyboardObserver.start();

        //выставляем начальное значение переменной "игра окончена" в ЛОЖЬ
        isGameOver = false;
        //создаем первую фигурку посередине сверху: x - половина ширины, y - 0.
        figure = FigureFactory.createRandomFigure(field.getWidth() / 2, 0);

        //пока игра не окончена
        while (!isGameOver) {
            //"наблюдатель" содержит события о нажатии клавиш?
            if (keyboardObserver.hasKeyEvents()) {
                //получить самое первое событие из очереди
                KeyEvent event = keyboardObserver.getEventFromTop();
                //Если равно символу 'q' - выйти из игры.
                if (event.getKeyChar() == 'q') return;
                //Если "стрелка влево" - сдвинуть фигурку влево
                if (event.getKeyCode() == KeyEvent.VK_LEFT)
                    figure.left();
                    //Если "стрелка вправо" - сдвинуть фигурку вправо
                else if (event.getKeyCode() == KeyEvent.VK_RIGHT)
                    figure.right();
                    //Если  код клавиши равен 12 ("цифра 5 на доп. клавиатуре") - повернуть фигурку
                else if (event.getKeyCode() == 12)
                    figure.rotate();
                    //Если "пробел" - фигурка падает вниз на максимум
                else if (event.getKeyCode() == KeyEvent.VK_SPACE)
                    figure.downMaximum();
            }

            step();             //делаем очередной шаг
            field.print();      //печатаем состояние "поля"
            Thread.sleep(300);  //пауза 300 миллисекунд - 1/3 секунды
        }

        //Выводим сообщение "Game Over"
        System.out.println("Game Over");
    }

    /**
     * Один шаг игры
     */
    public void step() {
        //опускам фигурку вниз

        //если разместить фигурку на текущем месте невозможно:
        //поднимаем обратно
        //приземляем
        //удаляем заполненные линии
        //создаем новую фигурку

    }

    /**
     * Сеттер для figure
     */
    public void setFigure(Figure figure) {
        this.figure = figure;
    }

    /**
     * Сеттер для field
     */
    public void setField(Field field) {
        this.field = field;
    }

    public static Tetris game;

    public static void main(String[] args) throws Exception {
        game = new Tetris(10, 20);
        game.run();
    }
}
